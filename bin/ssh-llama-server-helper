#!/usr/bin/env python3

import argparse
import logging
import subprocess
import sys
import re
import shlex
import threading
import time
import requests
import os
import socket
import errno
from typing import List, Optional, Tuple

SOCKET_PATH = os.path.expanduser("~/.ssh-llama-server-helper.socket")

def run_ssh_command(host: str, cmd: str, timeout: int = 10) -> subprocess.CompletedProcess:
    """Run an SSH command with logging"""
    logging.info(f"Running SSH command on {host}: {cmd}")
    return subprocess.run(['ssh', host, cmd], 
                        capture_output=True, 
                        text=True, 
                        timeout=timeout)

def detect_system(host: str) -> str:
    """Detect if remote system is Windows or Unix-like"""
    try:
        result = run_ssh_command(host, 'echo %OS%')
        if 'Windows' in result.stdout:
            return 'windows'
    except Exception as e:
        logging.warning(f"Failed to detect system on {host}: {e}")
    return 'unix'


def extract_arg(args: List[str], flag: str) -> Optional[str]:
    """Extract argument value following specified flag
    
    Args:
        args: List of command line arguments
        flag: The flag to look for (e.g. '-m' or '--port')
    
    Returns:
        The extracted string value, or None if not found
    """
    for i, arg in enumerate(args):
        if arg == flag and i + 1 < len(args):
            return args[i + 1]
    return None

def check_running_process(host: str, system: str, model: Optional[str]) -> Optional[str]:
    """Check if llama-server is running with the specified model"""
    if system == 'windows':
        cmd = 'wmic process where "name like \'%llama-server.exe\'" get name,commandline /format:csv'
        try:
            result = run_ssh_command(host, cmd)
            if 'llama-server.exe' in result.stdout:
                if model and model in result.stdout:
                    port_match = re.search(r'--port\s+(\d+)', result.stdout)
                    return port_match.group(1) if port_match else None
        except:
            pass
    else:
        cmd = "pgrep -f 'llama-server$'"
        try:
            result = subprocess.run(['ssh', host, cmd], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                ps_cmd = "ps aux | grep 'llama-server$' | grep -v grep"
                ps_result = run_ssh_command(host, ps_cmd)
                if model and model in ps_result.stdout:
                    port_match = re.search(r'--port\s+(\d+)', ps_result.stdout)
                    return port_match.group(1) if port_match else None
        except:
            pass
    return None

def kill_existing_process(host: str, system: str) -> None:
    """Kill existing llama-server process"""
    if system == 'windows':
        cmd = 'wmic process where "name like \'%llama-server.exe\'" delete'
    else:
        cmd = "pkill -f 'llama-server$'"
    
    try:
        run_ssh_command(host, cmd)
    except Exception as e:
        logging.warning(f"Failed to kill process on {host}: {e}")

def check_health(port: int, model: str, slot_save_path: Optional[str], host: str, system: str) -> None:
    """Check server health and restore model if needed"""
    health_url = f"http://localhost:{port}/health"
    
    while True:
        try:
            response = requests.get(health_url, timeout=5)
            if response.status_code == 200:
                break
        except:
            pass
        time.sleep(5)
    
    if slot_save_path and model:
        model_basename = os.path.basename(model)
        model_file = f"{model_basename}.bin"
        
        if system == 'windows':
            check_cmd = f"if exist \"{slot_save_path}\\{model_file}\" (echo exists)"
        else:
            check_cmd = f"test -f \"{slot_save_path}/{model_file}\" && echo exists"
        
        try:
            result = run_ssh_command(host, check_cmd)
            if 'exists' in result.stdout:
                restore_url = f"http://localhost:{port}/slots/0?action=restore"
                requests.post(restore_url, json={"filename": model_file})
        except:
            pass

def create_socket_listener(process: subprocess.Popen) -> None:
    """Create a unix socket listener for stop commands"""
    try:
        os.unlink(SOCKET_PATH)
    except OSError:
        if os.path.exists(SOCKET_PATH):
            raise
    
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(SOCKET_PATH)
    sock.listen(1)
    
    while True:
        try:
            connection, _ = sock.accept()
            try:
                data = connection.recv(1024).decode().strip()
                if data == "stop":
                    logging.info("Socket received stop signal, terminating process")
                    process.terminate()
                    try:
                        process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        process.kill()
                    break
            finally:
                connection.close()
        except Exception as e:
            logging.error(f"Socket error: {e}")
            break
    
    sock.close()
    try:
        os.unlink(SOCKET_PATH)
    except OSError:
        pass

def send_stop_signal() -> None:
    """Send stop signal to running instance"""
    if not os.path.exists(SOCKET_PATH):
        return
    
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(SOCKET_PATH)
        sock.sendall(b"stop\n")
        sock.close()
    except socket.error as e:
        if e.errno != errno.ECONNREFUSED:
            raise

def main() -> None:
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    parser = argparse.ArgumentParser(description='SSH llama-server helper')
    parser.add_argument('--host', required=True, help='SSH host')
    parser.add_argument('-k', '--kill', action='store_true', help='Stop running server')
    # rest of the args (server_args) are parsed by parser.parse_known_args
    
    args, server_args = parser.parse_known_args()
    print(server_args)
    
    if args.kill:
        logging.info("Received kill command, sending stop signal")
        send_stop_signal()
        logging.info("Stop signal sent successfully")
        return
    
    host: str = args.host
    logging.info(f"Starting helper for host: {host}")
    
    forwarded_port = extract_arg(server_args, '--port')
    
    if not forwarded_port:
        logging.error("No --port argument found in llama-server arguments")
        sys.exit(1)
    
    logging.info(f"Forwarding port: {forwarded_port}")
    system: str = detect_system(host)
    logging.info(f"Detected system type: {system}")
    model = extract_arg(server_args, '-m')
    slot_save_path = extract_arg(server_args, '--slot-save-path')
    
    running_port: Optional[str] = check_running_process(host, system, model)
    
    if running_port:
        logging.info(f"Found existing server running on port {running_port}")
        ssh_cmd = ['ssh', '-t', '-L', f'{forwarded_port}:127.0.0.1:{running_port}', host]
        logging.info(f"Starting existing SSH tunnel with command: {ssh_cmd}")
        process = subprocess.Popen(ssh_cmd)
    else:
        logging.info("No existing server found, starting new instance")
        kill_existing_process(host, system)
        logging.info("Killed any existing processes")
        
        ssh_cmd: List[str] = ['ssh', '-L', f'{forwarded_port}:127.0.0.1:{forwarded_port}', host, *server_args]
        logging.info(f"Starting new SSH tunnel with command: {ssh_cmd}")
        process = subprocess.Popen(ssh_cmd)
        
        if model and slot_save_path:
            health_thread = threading.Thread(
                target=check_health,
                args=(forwarded_port, model, slot_save_path, host, system),
                daemon=True
            )
            health_thread.start()
        
        socket_thread = threading.Thread(
            target=create_socket_listener,
            args=(process,),
            daemon=True
        )
        socket_thread.start()
        
        try:
            logging.info("Waiting for SSH tunnel process to complete")
            process.wait()
            logging.info("SSH tunnel process completed")
        except KeyboardInterrupt:
            logging.info("Received keyboard interrupt, terminating process")
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
        finally:
            logging.info("Cleaning up socket")
            send_stop_signal()

if __name__ == '__main__':
    main()
